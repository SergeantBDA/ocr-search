Добавь в проект FastAPI «приглашение к входу» (login/register) и сделай так, чтобы все веб-роуты были закрыты, кроме публичных /login и /register. Шаблоны страниц создай в каталоге templates/ с использованием HTMX. Подробные требования ниже — следуй им строго и подгоняй импорты под текущую структуру проекта.

1) Роутинг и защита

Пусть роутер веб-части (app/web/routes.py) будет закрыт целиком через зависимость:

from fastapi import APIRouter, Depends
from app.deps.auth import get_current_user

router = APIRouter(
    prefix="",
    tags=["web"],
    dependencies=[Depends(get_current_user)],
)


Роутер аутентификации уже существует (app/routers/auth/register, ./login, ./me) — оставить публичным.

Добавь публичные маршруты рендеринга страниц приглашений:

GET /login → страница логина (шаблон app/web/templates/login.html)

GET /register → страница регистрации (шаблон app/web/templates/register.html)

В app/main.py подключи:

app.include_router(auth_router_module.router)     # /auth/*
app.include_router(public_router)                 # /login, /register
app.include_router(web_router, dependencies=[Depends(get_current_user)])  # остальное закрыто

2) Шаблонизатор и статика

Подключи Jinja2Templates:

from fastapi.templating import Jinja2Templates
templates = Jinja2Templates(directory="templates")


Примонтируй /static (если нет):

from fastapi.staticfiles import StaticFiles
app.mount("/static", StaticFiles(directory="static"), name="static")


В layout подключай HTMX с CDN:

<script src="https://unpkg.com/htmx.org@1.9.12"></script>

3) Поведение 401: редирект на /login для браузера

Добавь обработчик 401, который:

Если Accept содержит text/html и URL не под /auth/*, делает RedirectResponse("/login").

Иначе возвращает стандартный JSON 401.

from starlette.requests import Request
from starlette.status import HTTP_401_UNAUTHORIZED
from fastapi.responses import RedirectResponse, JSONResponse

@app.exception_handler(HTTP_401_UNAUTHORIZED)
async def on_401(request: Request, exc):
  accept = request.headers.get("accept", "")
  if "text/html" in accept and not request.url.path.startswith("/auth"):
      return RedirectResponse(url="/login")
  return JSONResponse({"detail": "Not authenticated"}, status_code=401)

4) Публичные вьюхи для страниц приглашения (рендер)

Создай файл app/web/public.py с роутером:

from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

templates = Jinja2Templates(directory="templates")
router = APIRouter(tags=["public"])

@router.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

@router.get("/register", response_class=HTMLResponse)
def register_page(request: Request):
    return templates.TemplateResponse("register.html", {"request": request})

5) Шаблоны в app/web/templates/ (с HTMX)

Создай app/web/templates/_layout.html — базовый макет: контейнер, подключение HTMX, небольшой стиль.

Создай app/web/templates/login.html:

Форма без перезагрузки с HTMX, отправляет POST /auth/login (форма application/x-www-form-urlencoded, поля username, password).

При успехе — JS сохраняет access_token в localStorage и редиректит на домашний закрытый маршрут (например, /).

При ошибке — показывает сообщение об ошибке без перезагрузки.

Создай app/web/templates/register.html:

Форма POST app/router/auth/register (JSON через HTMX), при успехе — уведомление и кнопка «Войти» (линк на /login).

Минимальные версии шаблонов:

_layout.html

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>{{ title or "OCR Search" }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/htmx.org@1.9.12"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; }
    .container { max-width: 480px; margin: 8vh auto; padding: 24px; }
    .card { border: 1px solid #e5e7eb; padding: 20px; border-radius: 12px; }
    .btn { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; background:#f3f4f6; cursor:pointer }
    .field { margin: 10px 0 }
    .error { color: #b91c1c; margin-top: 8px }
    .muted { color:#6b7280; font-size: 14px }
  </style>
</head>
<body>
  <div class="container">
    {% block content %}{% endblock %}
  </div>

  <script>
    // Глобально подставляем Bearer для HTMX-запросов после логина
    document.body.addEventListener('htmx:configRequest', function(evt) {
      try {
        const t = localStorage.getItem('token');
        if (t) evt.detail.headers['Authorization'] = 'Bearer ' + t;
      } catch(_) {}
    });
  </script>
</body>
</html>


login.html

{% extends "_layout.html" %}
{% block content %}
<div class="card">
  <h1>Sign in</h1>
  <form id="login-form"
        hx-post="/auth/login"
        hx-target="#login-errors"
        hx-swap="innerHTML"
        onsubmit="return handleLogin(event)">
    <div class="field">
      <label>Email</label><br>
      <input name="username" type="email" required>
    </div>
    <div class="field">
      <label>Password</label><br>
      <input name="password" type="password" required>
    </div>
    <button class="btn" type="submit">Login</button>
  </form>
  <div id="login-errors" class="error"></div>
  <p class="muted">No account? <a href="/register">Create one</a></p>
</div>

<script>
async function handleLogin(e){
  e.preventDefault();
  const form = e.target;
  const fd = new FormData(form);
  const r = await fetch('/auth/login', { method: 'POST', body: fd });
  if (!r.ok) {
    const txt = await r.text();
    document.querySelector('#login-errors').textContent = 'Login failed: ' + txt;
    return false;
  }
  const data = await r.json();
  localStorage.setItem('token', data.access_token);
  window.location.href = '/';  // закрытая домашняя страница
  return false;
}
</script>
{% endblock %}


register.html

{% extends "_layout.html" %}
{% block content %}
<div class="card">
  <h1>Create account</h1>
  <form id="reg-form"
        hx-post="/auth/register"
        hx-headers='{"Content-Type":"application/json"}'
        hx-target="#reg-result"
        hx-swap="innerHTML"
        onsubmit="return submitReg(event)">
    <div class="field">
      <label>Email</label><br>
      <input id="reg-email" type="email" required>
    </div>
    <div class="field">
      <label>Password</label><br>
      <input id="reg-pass" type="password" minlength="8" required>
    </div>
    <button class="btn" type="submit">Register</button>
  </form>
  <div id="reg-result" class="muted"></div>
  <p class="muted">Already have an account? <a href="/login">Sign in</a></p>
</div>

<script>
async function submitReg(e){
  e.preventDefault();
  const email = document.getElementById('reg-email').value;
  const password = document.getElementById('reg-pass').value;
  const r = await fetch('/auth/register', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({email, password})
  });
  const node = document.getElementById('reg-result');
  if (!r.ok) {
    node.textContent = 'Registration failed';
    return false;
  }
  node.innerHTML = 'Registered. <a href="/login">Sign in</a>.';
  return false;
}
</script>
{% endblock %}

6) Дополнительно

Добавь «выход» (logout) — публичный маршрут POST /logout (или кнопка на клиенте), который просто чистит localStorage.token и редиректит на /login (клиентский JS).

Убедись, что OAuth2PasswordBearer(tokenUrl="/auth/login") в services/auth.py соответствует путям.

Оставь app/router/auth/*, /login, /register, /openapi.json, /docs, /swagger-ui в «белом списке» для 401-редиректа.

7) Acceptance criteria

Переход на любой закрытый URL в браузере перенаправляет на /login.

Успешный логин сохраняет JWT в localStorage и открывает закрытый маршрут.

Регистрация проходит без перезагрузки (HTMX), затем можно войти.

Вызовы HTMX и fetch к закрытым API автоматически получают заголовок Authorization: Bearer <token>.

Запросы без токена к закрытым API из внешних клиентов получают JSON 401.